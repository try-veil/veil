---
description: 
globs: packages/caddy/
alwaysApply: false
---
 ---
description: Guidelines for implementing Caddy server modules
globs: packages/caddy/**/*.go
alwaysApply: false
---
# Caddy Module Implementation

## Module Structure

Every Caddy module should follow this general structure:

```go
// Package declaration
package modulename

import (
    "github.com/caddyserver/caddy/v2"
    "github.com/caddyserver/caddy/v2/caddyconfig/caddyfile"
    "github.com/caddyserver/caddy/v2/modules/caddyhttp"
    // other imports
)

func init() {
    // Register module with Caddy
    caddy.RegisterModule(ModuleName{})
    
    // Register directives if applicable
    httpcaddyfile.RegisterHandlerDirective("directive_name", parseDirective)
}

// Module type definition
type ModuleName struct {
    // Configuration fields with JSON tags
    ConfigField1 string `json:"config_field_1,omitempty"`
    ConfigField2 int    `json:"config_field_2,omitempty"`
    
    // Private fields (not exported in JSON)
    privateField *someType `json:"-"`
    
    // Logger instance
    logger *zap.Logger
    ctx    caddy.Context
}

// CaddyModule returns the Caddy module information.
func (ModuleName) CaddyModule() caddy.ModuleInfo {
    return caddy.ModuleInfo{
        ID:  "http.handlers.module_name",
        New: func() caddy.Module { return new(ModuleName) },
    }
}

// Provision implements caddy.Provisioner.
func (m *ModuleName) Provision(ctx caddy.Context) error {
    m.logger = ctx.Logger().Named("module_name")
    m.ctx = ctx
    
    // Initialize module resources
    
    return nil
}

// Validate implements caddy.Validator.
func (m *ModuleName) Validate() error {
    // Validate configuration
    return nil
}

// Start implements caddy.App.
func (m *ModuleName) Start() error {
    // Start background processes
    return nil
}

// Stop implements caddy.App.
func (m *ModuleName) Stop() error {
    // Clean up resources
    return nil
}

// UnmarshalCaddyfile implements caddyfile.Unmarshaler.
func (m *ModuleName) UnmarshalCaddyfile(d *caddyfile.Dispenser) error {
    // Parse Caddyfile directives
    return nil
}

// ServeHTTP implements caddyhttp.MiddlewareHandler.
func (m *ModuleName) ServeHTTP(w http.ResponseWriter, r *http.Request, next caddyhttp.Handler) error {
    // Handle HTTP requests
    return next.ServeHTTP(w, r)
}
```

## Best Practices

1. **Module Registration**
   - Always register modules in `init()`
   - Use appropriate module IDs (e.g., `http.handlers.name` for HTTP handlers)

2. **Configuration**
   - Use JSON tags for all exported fields
   - Document each field with comments
   - Use `omitempty` for optional fields
   - Hide internal fields with `json:"-"`

3. **Error Handling**
   - Return detailed error messages
   - Log errors with appropriate log levels
   - Avoid panic in production code

4. **Middleware Implementation**
   - Always call next handler unless explicitly blocking the request
   - Be mindful of response headers that may already be written
   - Use context values for passing data between middlewares

5. **Resource Management**
   - Properly initialize resources in `Provision`
   - Clean up resources in `Stop`
   - Use context cancellation for long-running operations

6. **Logging**
   - Use structured logging with zap.Logger
   - Include relevant fields in log messages
   - Use appropriate log levels (debug, info, warn, error)

## Common Patterns

### Pattern: Key-Value Storage Access

```go
// Always get the storage from context in Provision
func (m *ModuleName) Provision(ctx caddy.Context) error {
    m.logger = ctx.Logger().Named("module_name")
    
    // Get storage from context
    kvStore, err := ctx.Storage().GetKV("module_namespece")
    if err != nil {
        return fmt.Errorf("getting KV store: %v", err)
    }
    m.store = kvStore
    
    return nil
}
```

### Pattern: Periodic Background Tasks

```go
// Start a periodic task
func (m *ModuleName) startPeriodicTask(ctx caddy.Context) {
    go func() {
        ticker := time.NewTicker(interval)
        defer ticker.Stop()
        
        for {
            select {
            case <-ticker.C:
                // Do periodic work
            case <-ctx.Done():
                // Context canceled, exit goroutine
                return
            }
        }
    }()
}
```

### Pattern: Configuration Validation

```go
// Validate configuration
func (m *ModuleName) Validate() error {
    if m.RequiredField == "" {
        return fmt.Errorf("required_field cannot be empty")
    }
    
    if m.NumberField < 0 {
        return fmt.Errorf("number_field must be positive")
    }
    
    return nil
}
```